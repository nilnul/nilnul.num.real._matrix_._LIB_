using nilnul.num.real.matrix.vec.co_.sociable;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace nilnul.num.real.matrix.vec.co_.conform.sop_
{
	static public class _SopX
	{
		/// <summary>
		///  <see cref="nilnul.num.real.vec.compart.str.co._MultiX"/> is more natural, as inner two traverse means same thing.
		///  for the left par, the outer and the inner, colscount, traverses the component of the vec of the matrix generated by mosaic. The middle enumerator, or the rowscount, traverses the size of the matrix generated by left par, a mosaic
		///  for the right par, the outer enumerator and, take right matrix as colwise, the rows enumerator, the mid indexer, count the arity (vec size, with all components combined)
		///  the cols traverses the size.
		///
		/// 
		/// We need to switch the mid and the inner indexer for the left to be as natural as <see cref="nilnul.num.real.vec.compart.str.co._MultiX"/>
		/// And still the inner shall be taken to the outmost, as it means the size of vecs for the wholematrix generated by the mosaic, which is each par.
		///
		/// In all, for the left, the rowcount means the size; other indexers mean the <see cref="obj.vec.Compart"/>
		/// For the right, colcount means the size, other indexers mean the compart.
		/// 
		/// 
		/// </summary>
		/// <remarks>
		/// <see cref="nilnul.num.real.vec.compart.str.co._MultiX"/>, only that:
		///		-) must be unihigh (rowcount) for the left, as we need it to be regarded as str of same compart
		///		_) each right matrix is colwise. right par must be uniwide (colcount).
		///		the above two conditions gurantee we get resultant matrix in equisize.
		///	This is understandalbe, as we require the sum over <var>t</var>.
		///		we still need the left and right can be zipped by multi, so for each pair, colcount of left matrix is rowcount of right matrix. That translates as <see cref="nilnul.num.real.vec.compart.str.co._MultiX"/> terms:
		///		: take par as whole to be a big matrix. vec (consolidate each smaller vec at each matrix) at both left and right is typed as the same component. that means:
		///		_) both the width of the left, and the height of the right, must be partitioned using same <see cref="nilnul.num_.positive.IStr"/>:<var>t</var>.
		/// 
		///
		/// </remarks>
		/// <param name="a">
		///		unihigh
		/// </param>
		/// <param name="b">
		///		uniwide
		/// </param>
		/// 
		/// <returns></returns>
		static public double[,] _Sop_bothAssumeDwelt1conform(
			IEnumerable<double[,]> a
			,
			IEnumerable<double[,]> b
		) {

			return _MultiComponentwiseX._Multi_assumeComponentwiseMultible(a,b).Aggregate(
				(x,y) =>
				num.real.matrix.co_.plusable._PlusX._Add_assumePlusable(x,y)
			);

		}
	}
}
